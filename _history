{"entries":[{"timestamp":1726673667706,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" id=\";F+Wo{o}Q6nWS=$m2$yl\" x=\"0\" y=\"0"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever"],[0,"\"></"]],"start1":12,"start2":12,"length1":135,"length2":102},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"Craft_Code.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":221,"start2":221,"length1":114,"length2":44}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"Craft_Code.ts","value":"/**\n * Blocks for Driving the kitronik Craft and Code Board\n */\n//% weight=100 color=#770c67 icon=\"\\uf0c3\" block=\"Craft_and_Code\"\n// subcategory=[\"More\"]\n//% group = '[\"BULB\", \"MOTOR\", \"SERVO\", \"TOUCHPAD\"]'\n\nnamespace Craft_and_Code {\n    let lastBulbBrightness: number = 100;\n    let lastMotorSpeed: number = 900;\n    let isBulbOn: boolean = false;\n    let isMotorOn: boolean = false; // Track whether the motor is on or off\n    let pwmValue = 0;\n    /**\n     * Turn Bulb ON and OFF\n     */\n    export enum BulbState {\n        //% block=\"ON\"\n        On,\n        //% block=\"OFF\"\n        Off\n    }\n\n    /**\n     * Turn motor ON and OFF\n     */\n    export enum MotorState {\n        //% block=\"ON\"\n        On,\n        //% block=\"OFF\"\n        Off\n    }\n\n    /**\n     * Set light brightness\n     */\n    export enum BulbBrightnessState {\n        //% block=\"Dim\"\n        Dim = 33,\n        //% block=\"Medium\"\n        Medium = 66,\n        //% block=\"Bright\"\n        Bright = 100\n    }\n\n    /**\n     * Set motor speed\n     */\n    export enum MotorSpeedState {\n        //% block=\"Slow\"\n        Slow = 350,\n        //% block=\"Medium\"\n        Medium = 600,\n        //% block=\"Fast\"\n        Fast = 900\n    }\n\n    //////////////////\n    ///Bulb-ON-OFF///\n    ////////////////\n\n    /**\n     * Turns on BULB  \n     */\n    //% blockId=Craft_and_Code_TurnBulb\n    //% block=\"Turn Bulb |%Bulbstate||\"\n    //% weight=100 blockGap=8\n    //% color=#770c67\n    //% group=\"BULB\"\n    //% x.min=0 x.max=1\n    //% x.fieldOptions.precision=1\n    export function TurnBulb(Bulbstate: BulbState): void {\n        isBulbOn = Bulbstate === BulbState.On;\n        if (isBulbOn) {\n            if (lastBulbBrightness == BulbBrightnessState.Bright) {\n                // Use digital write for 100%\n                pins.digitalWritePin(DigitalPin.P8, 1);\n            }\n            else {\n                // Use stored brightness value\n                pwmValue = (lastBulbBrightness / 100) * 1023;\n                pwmValue = Math.clamp(0, 1023, pwmValue);\n                pins.analogWritePin(AnalogPin.P8, pwmValue);\n            }\n        }\n        else {\n\n            pins.analogWritePin(AnalogPin.P8, 0);\n\n        }\n\n    }\n    /////////////////////////\n    //set Bulbulb brightness////\n    ////////////////////////\n\n    /**\n     *  Set Bulb brightness\n     */\n    //% subcategory=\"More\"\n    //% blockId=Craft_and_Code_SetBulbBrightness\n    //% block=\"Set Bulb Brightness |%brightnessstate|\"\n    //% weight=100 blockGap=8\n    //% color=#770c67\n    //% group=\"BULB\"\n\n    export function SetBulbBrightness(brightnessstate: BulbBrightnessState): void {\n        // Always store the last value, but do not calculate or apply it yet\n        lastBulbBrightness = brightnessstate as number;  // Store the last set value\n        if (isBulbOn) { // Check if the Bulb is on before setting brightness\n            pwmValue = (lastBulbBrightness / 100) * 1023;\n            pwmValue = Math.clamp(0, 1023, pwmValue);\n            pins.analogWritePin(AnalogPin.P8, pwmValue);\n        }\n    }\n\n    //////////////////\n    ///Motor-ON-OFF//\n    ////////////////\n\n    /**\n     * Turns on Motor\n     */\n    //% blockId=Craft_and_Code_TurnMotor\n    //% block=\"Turn Motor |%motorstate||\"\n    //% weight=100 blockGap=8\n    //% color=#770c67\n    //% group=\"MOTOR\"\n    //% y.min=0 y.max=1\n    //% y.fieldOptions.precision=1\n    export function TurnMotor(motorstate: MotorState): void {\n        if (motorstate === MotorState.On && !isMotorOn) {\n            isMotorOn = true;\n            // Gradually increase the motor speed to last set speed\n            let totalDuration = 500; // Total duration in milliseconds to reach desired speed.\n            let steps = 100; // Number of steps to full power.\n            let increment = lastMotorSpeed / steps; // Speed increment value for each step.\n            let pauseDuration = totalDuration / steps; // Time to pause between each increment, must be an integer.\n\n            // Gradually increase the motor speed\n            for (let index = 1; index <= steps; index++) {\n                let speed = Math.round(increment * index);\n                pins.analogWritePin(AnalogPin.P12, speed);\n                basic.pause(pauseDuration);\n            }\n\n        } else if (motorstate === MotorState.Off && isMotorOn) {\n            isMotorOn = false;\n\n            pins.analogWritePin(AnalogPin.P12, 0);\n        }\n\n    }\n\n\n    //////////////////\n    //Motor-SPEED///\n    ////////////////\n\n    /**\n     * Set motor speed\n     */\n    //% subcategory=\"More\"\n    //% blockId=Craft_and_Code_SetMotorSpeed\n    //% block=\"Set Motor Speed |%speedstate|\"\n    //% weight=100 blockGap=8\n    //% color=#770c67\n    //% group=\"Motor\"\n    export function SetMotorSpeed(speedstate: MotorSpeedState): void {\n        // Always store the last value\n        let newSpeed = speedstate as number;\n\n        // If the motor is on, then update the speed with smooth transition\n        if (isMotorOn) {\n            let currentSpeed = lastMotorSpeed;\n\n            // Calculate the difference and steps for smooth transition\n            let speedDifference = newSpeed - currentSpeed;\n            let totalDuration = 500; // Total duration in milliseconds to reach desired speed.\n            let steps = 100; // Number of steps to full power.\n            let increment = speedDifference / steps; // Speed increment value for each step.\n            let pauseDuration = totalDuration / steps; // Time to pause between each increment, must be an integer.\n\n            // Gradually adjust the motor speed\n            for (let index = 1; index <= steps; index++) {\n                let speed = Math.round(currentSpeed + (increment * index));\n                pins.analogWritePin(AnalogPin.P12, speed);\n                basic.pause(pauseDuration);\n            }\n        }\n\n        // Update the last motor speed\n        lastMotorSpeed = newSpeed;\n    }\n    //////\n    ////////\n    ////SERVO////\n    //////////////\n\n    /**\n     * Set Servo Angle\n     */\n    //% blockId=Craft_and_Code_SetServoAngle\n    //% block=\"Set Servo Angle |%degrees| degrees\"\n    //% color=#770c67\n    //% degrees.min=0 degrees.max=180\n    //% degrees.defl=90\n    //% degrees.shadow=\"protractorPicker\"\n    //% weight=100 blockGap=8\n    //% group=\"SERVO\"\n    export function setServoAngle(degrees: number) {\n        // Check if the degrees are greater than 180\n        if (degrees > 180 || degrees < 0) {\n            console.error(\"Error: Angle cannot be more than 180 degrees or less then 0\");\n            return;\n        }\n\n        // If degrees are within the valid range, set the servo angle\n        pins.servoWritePin(AnalogPin.P2, degrees);\n\n    }\n\n\n    //////////////////////\n    //Touchpad Functions//\n    //////////////////////\n    //let samples = 12; // Number of readings for calibration\n\n    /**\n     * Wait for Touchpad\n     */\n    //% subcategory=\"More\"\n    //% block=\"Wait for Touchpad\"\n    //% blockId=Craft_and_Code_Wait_for_touchpad\n    //% weight=100 blockGap=8\n    //% color=#770c67\n    //% group=\"TOUCHPAD\"\n    export function waitForTouchPad(): void {\n\n        let touchPadState = false; // Initially, the touchpad is not pressed\n\n        // Now, wait for the touchpad to be pressed\n        while (!touchPadState) {\n            touchPadState = getTouchPadState(); // Reading the touchpad state only here\n            basic.pause(1);\n\n        }\n        while (touchPadState) {\n            touchPadState = getTouchPadState();\n            basic.pause(1);\n        }\n    }\n    let lastAverageReading = 0;\n    let firstSample = true;\n    /**\n     * Get TouchPad State\n     */\n    //% subcategory=\"More\"\n    //% block=\"TouchPad pressed\"\n    //% blockId=Touchpad pressed\n    //% weight=100 blockGap=8\n    //% color=#770c67\n    //% group=\"TOUCHPAD\"\n    export function getTouchPadState(): boolean {\n        let currentReading = 0;\n        let samplesTotal = 0;\n        let sampleCount = 0;\n        let startTime_1 = input.runningTime();\n\n        while (input.runningTime() - startTime_1 < 40) {\n            pins.digitalWritePin(DigitalPin.P0, 1); // Turn ON the Touchpad pin\n\n            basic.pause(1);\n            currentReading = pins.analogReadPin(AnalogPin.P0);\n\n            samplesTotal += currentReading; // Add current reading to total\n            sampleCount++; // Increment the sample count\n        }\n\n        pins.digitalWritePin(DigitalPin.P0, 0);\n\n        let isTouched = false;\n        let currentAverageReading = samplesTotal / sampleCount; // Calculate the average\n\n        if (firstSample) {\n            lastAverageReading = currentAverageReading;\n            firstSample = false;  // Reset the firstSample flag after first use\n        } else {\n            isTouched = currentAverageReading > lastAverageReading * 1.05;\n            lastAverageReading = currentAverageReading;\n        }\n\n        return isTouched;\n    }\n\n\n    //////////////////\n    ////SWITCH///////\n    ////////////////\n    /**\n     * Switched state\n     */\n    //% blockId=Craft_and_Code_SwitchState\n    //% block=\"SwitchClosed\"\n    //% weight=100 blockGap=8\n    //% color=#770c67\n    //% group=\"SWITCH\"\n    export function SwitchClosed(): boolean {\n        //switch is connected to Pin P1\n        return pins.digitalReadPin(DigitalPin.P1) == 1;\n    }\n\n}\n\n"}]}],"snapshots":[{"timestamp":1726673667705,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Craft_Code\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1726673899347}